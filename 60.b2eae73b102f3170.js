"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[60],{60:(z,h,n)=>{n.r(h),n.d(h,{default:()=>w});var l=n(8832),v=n(661),m=n(1760),p=n(150),f=n(7355),x=n(2037),P=n(109),y=n(1307),j=n(5022),C=n(901),c=n(7525),d=n(3559);const D={mask:/^\d{0,3}$/,plugins:[(0,d.mz)()]};var e=n(1489),E=n(5014);let b=(()=>{var t;class a{constructor(){this.maskitoOptions=D,this.value="12345"}}return(t=a).\u0275fac=function(o){return new(o||t)},t.\u0275cmp=e.VBU({type:t,selectors:[["plugins-initial-calibration-doc-example-2"]],decls:3,vars:4,consts:[[3,"ngModelChange","ngModel"],["tuiTextfieldLegacy","",3,"maskito"]],template:function(o,s){1&o&&(e.j41(0,"tui-input",0),e.mxI("ngModelChange",function(r){return e.DH7(s.value,r)||(s.value=r),r}),e.EFF(1," Enter number "),e.nrm(2,"input",1),e.k0s()),2&o&&(e.xc7("max-width",20,"rem"),e.R50("ngModel",s.value),e.R7$(2),e.Y8G("maskito",s.maskitoOptions))},dependencies:[l.YN,l.BC,l.vS,p.uj,c.zi,c.mp,c.Ws,E.Bw],encapsulation:2,changeDetection:0}),a})();const M={mask:/^[0-9\uff10-\uff19]*$/,plugins:[(0,d.DR)()]};let T=(()=>{var t;class a{constructor(){this.maskitoOptions=M,this.value=""}}return(t=a).\u0275fac=function(o){return new(o||t)},t.\u0275cmp=e.VBU({type:t,selectors:[["plugins-strict-composition-doc-example-3"]],decls:2,vars:4,consts:[[3,"ngModelChange","maskito","ngModel"]],template:function(o,s){1&o&&(e.j41(0,"tui-input",0),e.mxI("ngModelChange",function(r){return e.DH7(s.value,r)||(s.value=r),r}),e.EFF(1," Enter number "),e.k0s()),2&o&&(e.xc7("max-width",20,"rem"),e.Y8G("maskito",s.maskitoOptions),e.R50("ngModel",s.value))},dependencies:[l.YN,l.BC,l.vS,p.uj,c.zi,c.mp,c.Ws],encapsulation:2,changeDetection:0}),a})();const k=(0,n(7941).TK)({maximumFractionDigits:2}),L={...k,plugins:[...k.plugins,(0,d._E)()]};let G=(()=>{var t;class a{constructor(){this.maskitoOptions=L,this.value=""}log(o){console.info(o)}}return(t=a).\u0275fac=function(o){return new(o||t)},t.\u0275cmp=e.VBU({type:t,selectors:[["plugins-change-event-doc-example-4"]],decls:3,vars:5,consts:[[3,"ngModelChange","maskito","ngModel"],["tuiTextfieldLegacy","",3,"change","maskito"]],template:function(o,s){1&o&&(e.j41(0,"tui-input",0),e.mxI("ngModelChange",function(r){return e.DH7(s.value,r)||(s.value=r),r}),e.EFF(1," Enter number "),e.j41(2,"input",1),e.bIt("change",function(r){return s.log(r)}),e.k0s()()),2&o&&(e.xc7("max-width",20,"rem"),e.Y8G("maskito",s.maskitoOptions),e.R50("ngModel",s.value),e.R7$(2),e.Y8G("maskito",s.maskitoOptions))},dependencies:[l.YN,l.BC,l.vS,p.uj,c.zi,c.mp,c.Ws,E.Bw],encapsulation:2,changeDetection:0}),a})();const R={mask:/^\d*\.?\d*$/,plugins:[(t,a)=>{const i=()=>{t.value.startsWith(".")&&(0,d.Gq)(t,`0${t.value}`)};return t.addEventListener("blur",i),()=>t.removeEventListener("blur",i)}]};var g=n(6110),Y=n(5639),F=n(2734);function I(t,a){if(1&t&&(e.j41(0,"p",6)(1,"strong"),e.EFF(2,"Plugins"),e.k0s(),e.EFF(3," are functions that are called with input/textarea element and mask options as arguments upon mask initialization. They can optionally return cleanup logic and allow you to extend mask with arbitrary additional behavior. "),e.k0s(),e.j41(4,"section",7)(5,"h2"),e.EFF(6,"Create Your Own Plugin"),e.k0s(),e.j41(7,"p"),e.EFF(8,"Let's explore this concept by solving an oversimplified task."),e.k0s(),e.j41(9,"p"),e.EFF(10," Imagine that you've created a mask to allow users entering only number with decimal part. If you explored documentation section "),e.j41(11,"a",8),e.EFF(12,' "Mask\xa0expression" '),e.k0s(),e.EFF(13," , it is piece of cake for you \u2013 everything is achieved by a base knowledge of "),e.j41(14,"code"),e.EFF(15,"RegExp"),e.k0s(),e.EFF(16," and a few code lines: "),e.k0s(),e.nrm(17,"tui-doc-code",9),e.j41(18,"p"),e.EFF(19," It works fine, users and your boss are "),e.j41(20,"strong"),e.EFF(21,"almost"),e.k0s(),e.EFF(22," completely satisfied. The last desired detail - no empty integer part on blur. "),e.k0s(),e.j41(23,"p"),e.EFF(24,"For example, imagine that you have the such textfield:"),e.k0s(),e.j41(25,"tui-textfield")(26,"label",10),e.EFF(27,"Enter number"),e.k0s(),e.nrm(28,"input",11),e.k0s(),e.j41(29,"p"),e.EFF(30," User sets caret before point => press "),e.j41(31,"kbd"),e.EFF(32,"Backspace"),e.k0s(),e.EFF(33," => blur textfield. The result is following: "),e.k0s(),e.j41(34,"tui-textfield")(35,"label",10),e.EFF(36,"Enter number"),e.k0s(),e.nrm(37,"input",12),e.k0s(),e.j41(38,"p"),e.EFF(39,' Looks not perfect, right? You need to "send signal" for users that the such incomplete value will be interpreted as '),e.j41(40,"code"),e.EFF(41,"0.23"),e.k0s(),e.EFF(42," in your system. One way to do it \u2013 pads leading point with zero on blur event. Let's use the plugin for achieve it! "),e.k0s(),e.nrm(43,"tui-doc-code",9),e.j41(44,"p")(45,"strong"),e.EFF(46,"Good job!"),e.k0s(),e.EFF(47," Now, you are ready to create your own plugin. Explore the result in action (the created mask is applied to the textfield below): "),e.k0s(),e.j41(48,"tui-textfield",13)(49,"label",10),e.EFF(50,"Enter number"),e.k0s(),e.nrm(51,"input",14),e.k0s()(),e.j41(52,"section",7)(53,"h2",7),e.EFF(54,"Explore built-in plugins"),e.k0s(),e.j41(55,"div",15)(56,"a",16)(57,"h3",17),e.EFF(58," @maskito/core "),e.j41(59,"span",18)(60,"ul",19)(61,"li",20),e.EFF(62,"maskitoInitialCalibrationPlugin"),e.k0s(),e.j41(63,"li",20),e.EFF(64,"maskitoStrictCompositionPlugin"),e.k0s(),e.j41(65,"li",20),e.EFF(66,"maskitoChangeEventPlugin"),e.k0s()()()()(),e.j41(67,"a",21)(68,"h3",17),e.EFF(69," @maskito/kit "),e.j41(70,"span",18)(71,"ul",19)(72,"li",20),e.EFF(73,"maskitoSelectionChangeHandler, maskitoCaretGuard"),e.k0s(),e.j41(74,"li",20),e.EFF(75," maskitoEventHandler, maskitoAddOnFocusPlugin, maskitoRemoveOnBlurPlugin "),e.k0s(),e.j41(76,"li",20),e.EFF(77,"maskitoRejectEvent"),e.k0s()()()()()()(),e.nrm(78,"next-steps")),2&t){const i=e.XpG();e.R7$(11),e.Y8G("routerLink",i.maskExpressionDocPage),e.R7$(6),e.Y8G("code",i.oversimplifiedNumberMask),e.R7$(8),e.xc7("max-width",20,"rem"),e.R7$(3),e.Y8G("readOnly",!0),e.R7$(6),e.xc7("max-width",20,"rem"),e.R7$(3),e.Y8G("readOnly",!0),e.R7$(6),e.Y8G("code",i.padsZeroPlugin),e.R7$(5),e.xc7("max-width",20,"rem"),e.Y8G("tuiTextfieldCleaner",!1),e.R7$(3),e.Y8G("maskito",i.documentationMask),e.R7$(16),e.Y8G("routerLink",i.kitPluginsDocPage)}}function $(t,a){if(1&t&&(e.j41(0,"strong"),e.EFF(1,"Maskito"),e.k0s(),e.EFF(2," libraries were created to prevent "),e.j41(3,"u"),e.EFF(4,"only user"),e.k0s(),e.EFF(5," from typing invalid value. However, sometimes you (developer) need to enable mask but you not sure that you programmatically patched textfield with valid value. In this case you can use "),e.j41(6,"a",8)(7,"code"),e.EFF(8,"maskitoTransform"),e.k0s()(),e.EFF(9," or just add "),e.j41(10,"code"),e.EFF(11,"maskitoInitialCalibrationPlugin"),e.k0s(),e.EFF(12," to mask options. ")),2&t){const i=e.XpG(2);e.R7$(6),e.Y8G("routerLink",i.transformerDocPage)}}function B(t,a){1&t&&(e.j41(0,"p",6),e.EFF(1," By default, "),e.j41(2,"strong"),e.EFF(3,"Maskito"),e.k0s(),e.EFF(4," does not break IME Composition and waits until "),e.j41(5,"a",25)(6,"code"),e.EFF(7,"compositionend"),e.k0s()(),e.EFF(8," fires to begin calibration of the textfield's value. It is especially important for East Asian languages such as Chinese, Japanese, Korean, and other languages with complex characters. "),e.k0s(),e.j41(9,"p"),e.EFF(10," However, sometimes this behaviour is not desired and you can want to enable mask validation on every keystroke (to be like a classic not-composition input). For example, some Android devices with enabled system autocomplete can interpret user's input as part of composition event \u2013 waiting for "),e.j41(11,"code"),e.EFF(12,"compositionend"),e.k0s(),e.EFF(13," can be not required for some cases (e.g. entering of numbers or your application is not used by East Asian clients). For this cases, you can use "),e.j41(14,"code"),e.EFF(15,"maskitoStrictCompositionPlugin"),e.k0s(),e.EFF(16," . It applies mask's constraints on ANY intermediate value of IME composition. "),e.k0s())}function S(t,a){1&t&&(e.EFF(0," Native "),e.j41(1,"a",26)(2,"code"),e.EFF(3,"beforeinput"),e.k0s()(),e.EFF(4," event default behavior is cancelled to process user entered invalid value. This causes native "),e.j41(5,"a",27)(6,"code"),e.EFF(7,"change"),e.k0s()(),e.EFF(8," event to "),e.j41(9,"strong"),e.EFF(10,"NOT"),e.k0s(),e.EFF(11," be dispatched by browser. A "),e.j41(12,"code"),e.EFF(13,"change"),e.k0s(),e.EFF(14," event, as opposed to "),e.j41(15,"code"),e.EFF(16,"input"),e.k0s(),e.EFF(17," , is triggered only when user left the field and value was changed during interaction. If you rely on this behavior, add "),e.j41(18,"code"),e.EFF(19,"maskitoChangeEventPlugin"),e.k0s(),e.EFF(20," to your mask configuration. It will dispatch synthetic "),e.j41(21,"code"),e.EFF(22,"change"),e.k0s(),e.EFF(23," event using the same logic. "))}function N(t,a){if(1&t&&(e.j41(0,"tui-doc-example",22),e.DNE(1,$,13,1,"ng-template",null,0,e.C5r),e.nrm(3,"plugins-initial-calibration-doc-example-2"),e.k0s(),e.j41(4,"tui-doc-example",23),e.DNE(5,B,17,0,"ng-template",null,1,e.C5r),e.nrm(7,"plugins-strict-composition-doc-example-3"),e.k0s(),e.j41(8,"tui-doc-example",24),e.DNE(9,S,24,0,"ng-template",null,2,e.C5r),e.nrm(11,"plugins-change-event-doc-example-4"),e.k0s()),2&t){const i=e.sdS(2),o=e.sdS(6),s=e.sdS(10),u=e.XpG();e.Y8G("content",u.initialCalibrationExample)("description",i),e.R7$(4),e.Y8G("content",u.strictCompositionExample)("description",o),e.R7$(4),e.Y8G("content",u.changeEventExample)("description",s)}}let w=(()=>{var t;class a{constructor(){this.transformerDocPage=`/${m.$.Transformer}`,this.maskExpressionDocPage=`/${m.$.MaskExpression}`,this.kitPluginsDocPage=`/${m.$.KitPlugins}`,this.documentationMask=R,this.oversimplifiedNumberMask=n.e(4328).then(n.t.bind(n,4328,17)),this.padsZeroPlugin=n.e(3572).then(n.t.bind(n,3572,17)),this.initialCalibrationExample={[m.w.MaskitoOptions]:n.e(4329).then(n.t.bind(n,4329,17)),"index.ts":n.e(9151).then(n.t.bind(n,9151,17))},this.strictCompositionExample={[m.w.MaskitoOptions]:n.e(6259).then(n.t.bind(n,6259,17))},this.changeEventExample={[m.w.MaskitoOptions]:n.e(317).then(n.t.bind(n,317,17))}}}return(t=a).\u0275fac=function(o){return new(o||t)},t.\u0275cmp=e.VBU({type:t,selectors:[["plugins-mode-doc-page"]],decls:3,vars:0,consts:[["initialCalibrationDescription",""],["strictCompositionDescription",""],["changeEventDescription",""],["header","Plugins"],["pageTab","Documentation"],["pageTab","Built-in core plugins"],[1,"tui-space_top-0"],[1,"tui-space_top-8"],["tuiLink","",3,"routerLink"],[3,"code"],["tuiLabel",""],["ngModel","1.23","tuiTextfield","",3,"readOnly"],["ngModel",".23","tuiTextfield","",3,"readOnly"],[3,"tuiTextfieldCleaner"],["ngModel","1.23","tuiTextfield","",3,"maskito"],[1,"cards"],["routerLink","Built-in_core_plugins","tuiCardLarge","","tuiHeader","","tuiSurface","elevated"],["tuiTitle",""],["tuiSubtitle","",1,"tui-space_top-2"],[1,"tui-list"],[1,"tui-list__item"],["tuiCardLarge","","tuiHeader","","tuiSurface","elevated",3,"routerLink"],["id","initial-calibration","heading","For initial calibration",3,"content","description"],["id","strict-composition","heading","For composition event",3,"content","description"],["id","change-event","heading","For change event",3,"content","description"],["href","https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionend_event","rel","noreferrer","target","_blank","tuiLink",""],["href","https://developer.mozilla.org/en-US/docs/Web/API/Element/beforeinput_event","target","_blank","tuiLink",""],["href","https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event","target","_blank","tuiLink",""]],template:function(o,s){1&o&&(e.j41(0,"tui-doc-page",3),e.DNE(1,I,79,14,"ng-template",4)(2,N,12,6,"ng-template",5),e.k0s())},dependencies:[l.YN,l.me,l.BC,l.vS,p.uj,C.g,b,T,G,v.Wk,g.MN,g.FS,g.e3,g.ic,y.QO,j.IF,f.Jc,x.O,Y.z,F.Bw,F.j8,F.TB,P.R],styles:[".cards[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;gap:1rem}.cards[_ngcontent-%COMP%]   [tuiCardLarge][_ngcontent-%COMP%]{flex:1;min-inline-size:20rem}@media screen and (min-width: 64em){.cards[_ngcontent-%COMP%]   [tuiCardLarge][_ngcontent-%COMP%]{max-inline-size:45%}}"],changeDetection:0}),a})()}}]);